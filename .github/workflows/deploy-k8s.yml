name: Deploy to K8s

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-backend-services:
    name: Build Backend Services (PyTorch)
    runs-on: self-hosted
    environment: prod

    env:
      DOCKER_COMPOSE_FILE: docker-compose.prod.yml

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Clean Docker build cache
        run: |
          docker builder prune -a -f
          docker system prune -f

      - name: Build Pipeline service
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build pipeline

      - name: Build Backend service
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build backend

  build-frontend-services:
    name: Build Frontend Services
    runs-on: self-hosted
    environment: prod
    needs: build-backend-services

    env:
      DOCKER_COMPOSE_FILE: docker-compose.prod.yml

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Public Frontend
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build public-frontend

      - name: Build Pipeline Frontend
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build pipeline-frontend

  deploy:
    name: Deploy to K8s
    runs-on: self-hosted
    environment: prod
    needs: [build-backend-services, build-frontend-services]

    env:
      DOCKER_HOST: tcp://10.0.0.35:2375
      K8S_HOST: 10.0.0.40
      DOCKER_COMPOSE_FILE: docker-compose.prod.yml
      DOCKER_CONTEXT_NAME: fogcam-ctx

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker context
        run: |
          docker context create ${{ env.DOCKER_CONTEXT_NAME }} \
            --docker host=${{ env.DOCKER_HOST }} || true

      - name: Save and load images to remote Docker
        run: |
          # Transfer images to remote Docker (your K3s nodes will pull from here)
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} config --services | while read service; do
            image_name="karlcam-${service}:latest"
            echo "Transferring $image_name to remote Docker..."
            docker save "$image_name" | docker --context ${{ env.DOCKER_CONTEXT_NAME }} load
          done

      - name: Deploy to K8s
        run: |
          # Update manifests with correct image names
          for file in k8s/*.yaml; do
            sed -i 's|image: karlcam/\([^:]*\):latest|image: karlcam-\1:latest|g' $file
          done
          
          # Copy manifests to K8s control plane
          scp -o StrictHostKeyChecking=no k8s/*.yaml ubuntu@${{ env.K8S_HOST }}:/tmp/
          
          # Apply manifests
          ssh -o StrictHostKeyChecking=no ubuntu@${{ env.K8S_HOST }} << 'EOF'
            sudo kubectl apply -f /tmp/00-namespace.yaml
            sudo kubectl apply -f /tmp/01-storage.yaml
            sudo kubectl apply -f /tmp/02-pipeline.yaml
            sudo kubectl apply -f /tmp/03-backend.yaml
            sudo kubectl apply -f /tmp/04-public-frontend.yaml
            sudo kubectl apply -f /tmp/05-pipeline-frontend.yaml
            
            # Wait for deployments
            sudo kubectl -n karlcam rollout status deployment --timeout=5m
            
            # Show status
            sudo kubectl -n karlcam get all
          EOF

      - name: Cleanup
        if: always()
        run: |
          docker context rm ${{ env.DOCKER_CONTEXT_NAME }} --force || true
          docker image prune -f