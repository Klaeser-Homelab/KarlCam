name: Deploy to K8s

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-and-deploy-pipeline:
    name: Build and Deploy Pipeline Service
    runs-on: self-hosted
    environment: prod

    env:
      DOCKER_COMPOSE_FILE: docker-compose.prod.yml
      DOCKER_HOST: tcp://10.0.0.35:2375
      K8S_HOST: 10.0.0.40
      DOCKER_CONTEXT_NAME: karlcam-pipeline-ctx

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Pipeline service
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build pipeline

      - name: List built images
        run: |
          echo "=== Pipeline images after build ==="
          docker images | grep -E "(karlcam|pipeline)" || echo "No matching images found"

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.K8S_HOST }} >> ~/.ssh/known_hosts

      - name: Set up Docker context
        run: |
          docker context create ${{ env.DOCKER_CONTEXT_NAME }} \
            --docker host=${{ env.DOCKER_HOST }} || true

      - name: Transfer and push pipeline image to registry
        run: |
          local_image="karlcam-pipeline:latest"
          registry_image="10.0.0.35:5000/karlcam-pipeline:latest"
          
          echo "Transferring $local_image to remote Docker..."
          docker save "$local_image" | docker --context ${{ env.DOCKER_CONTEXT_NAME }} load
          
          echo "Tagging for registry: $registry_image"
          docker --context ${{ env.DOCKER_CONTEXT_NAME }} tag "$local_image" "$registry_image"
          
          echo "Pushing to registry: $registry_image"
          docker --context ${{ env.DOCKER_CONTEXT_NAME }} push "$registry_image"

      - name: Deploy pipeline service to K8s
        run: |
          # Update manifests with registry image names
          sed -i 's|image: karlcam/\([^:]*\):latest|image: 10.0.0.35:5000/karlcam-\1:latest|g' k8s/00-namespace.yaml
          sed -i 's|image: karlcam/\([^:]*\):latest|image: 10.0.0.35:5000/karlcam-\1:latest|g' k8s/01-storage.yaml
          sed -i 's|image: karlcam/\([^:]*\):latest|image: 10.0.0.35:5000/karlcam-\1:latest|g' k8s/02-pipeline.yaml
          
          # Copy pipeline manifests to K8s control plane
          scp k8s/00-namespace.yaml k8s/01-storage.yaml k8s/02-pipeline.yaml ubuntu@${{ env.K8S_HOST }}:/tmp/
          
          # Apply pipeline manifests
          ssh ubuntu@${{ env.K8S_HOST }} << 'EOF'
            sudo kubectl apply -f /tmp/00-namespace.yaml
            sudo kubectl apply -f /tmp/01-storage.yaml
            sudo kubectl apply -f /tmp/02-pipeline.yaml
            
            # Wait for pipeline deployment
            sudo kubectl -n karlcam rollout status deployment/karlcam-pipeline --timeout=5m
            
            # Show pipeline status
            sudo kubectl -n karlcam get pods | grep pipeline
          EOF

      - name: Cleanup
        if: always()
        run: |
          docker context rm ${{ env.DOCKER_CONTEXT_NAME }} --force || true

  build-and-deploy-backend:
    name: Build and Deploy Backend Service
    runs-on: self-hosted
    environment: prod
    needs: build-and-deploy-pipeline

    env:
      DOCKER_COMPOSE_FILE: docker-compose.prod.yml
      DOCKER_HOST: tcp://10.0.0.35:2375
      K8S_HOST: 10.0.0.40
      DOCKER_CONTEXT_NAME: karlcam-backend-ctx

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Backend service
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build backend

      - name: List built images
        run: |
          echo "=== Backend images after build ==="
          docker images | grep -E "(karlcam|backend)" || echo "No matching images found"

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.K8S_HOST }} >> ~/.ssh/known_hosts

      - name: Set up Docker context
        run: |
          docker context create ${{ env.DOCKER_CONTEXT_NAME }} \
            --docker host=${{ env.DOCKER_HOST }} || true

      - name: Transfer and push backend image to registry
        run: |
          local_image="karlcam-backend:latest"
          registry_image="10.0.0.35:5000/karlcam-backend:latest"
          
          echo "Transferring $local_image to remote Docker..."
          docker save "$local_image" | docker --context ${{ env.DOCKER_CONTEXT_NAME }} load
          
          echo "Tagging for registry: $registry_image"
          docker --context ${{ env.DOCKER_CONTEXT_NAME }} tag "$local_image" "$registry_image"
          
          echo "Pushing to registry: $registry_image"
          docker --context ${{ env.DOCKER_CONTEXT_NAME }} push "$registry_image"

      - name: Deploy backend service to K8s
        run: |
          # Update manifests with registry image names
          sed -i 's|image: karlcam/\([^:]*\):latest|image: 10.0.0.35:5000/karlcam-\1:latest|g' k8s/03-backend.yaml
          
          # Copy backend manifests to K8s control plane
          scp k8s/03-backend.yaml ubuntu@${{ env.K8S_HOST }}:/tmp/
          
          # Apply backend manifests
          ssh ubuntu@${{ env.K8S_HOST }} << 'EOF'
            sudo kubectl apply -f /tmp/03-backend.yaml
            
            # Wait for backend deployment
            sudo kubectl -n karlcam rollout status deployment/karlcam-backend --timeout=5m
            
            # Show backend status
            sudo kubectl -n karlcam get pods | grep backend
          EOF

      - name: Cleanup
        if: always()
        run: |
          docker context rm ${{ env.DOCKER_CONTEXT_NAME }} --force || true

  build-and-deploy-public-frontend:
    name: Build and Deploy Public Frontend
    runs-on: self-hosted
    environment: prod
    needs: build-and-deploy-backend

    env:
      DOCKER_COMPOSE_FILE: docker-compose.prod.yml
      DOCKER_HOST: tcp://10.0.0.35:2375
      K8S_HOST: 10.0.0.40
      DOCKER_CONTEXT_NAME: karlcam-public-frontend-ctx

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Public Frontend
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build public-frontend

      - name: List built images
        run: |
          echo "=== Public frontend images after build ==="
          docker images | grep -E "(karlcam|frontend)" || echo "No matching images found"

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.K8S_HOST }} >> ~/.ssh/known_hosts

      - name: Set up Docker context
        run: |
          docker context create ${{ env.DOCKER_CONTEXT_NAME }} \
            --docker host=${{ env.DOCKER_HOST }} || true

      - name: Transfer and push public frontend image to registry
        run: |
          local_image="karlcam-public-frontend:latest"
          registry_image="10.0.0.35:5000/karlcam-public-frontend:latest"
          
          echo "Transferring $local_image to remote Docker..."
          docker save "$local_image" | docker --context ${{ env.DOCKER_CONTEXT_NAME }} load
          
          echo "Tagging for registry: $registry_image"
          docker --context ${{ env.DOCKER_CONTEXT_NAME }} tag "$local_image" "$registry_image"
          
          echo "Pushing to registry: $registry_image"
          docker --context ${{ env.DOCKER_CONTEXT_NAME }} push "$registry_image"

      - name: Deploy public frontend service to K8s
        run: |
          # Update manifests with registry image names
          sed -i 's|image: karlcam/\([^:]*\):latest|image: 10.0.0.35:5000/karlcam-\1:latest|g' k8s/04-public-frontend.yaml
          
          # Copy public frontend manifests to K8s control plane
          scp k8s/04-public-frontend.yaml ubuntu@${{ env.K8S_HOST }}:/tmp/
          
          # Apply public frontend manifests
          ssh ubuntu@${{ env.K8S_HOST }} << 'EOF'
            sudo kubectl apply -f /tmp/04-public-frontend.yaml
            
            # Wait for public frontend deployment
            sudo kubectl -n karlcam rollout status deployment/karlcam-public-frontend --timeout=5m
            
            # Show public frontend status
            sudo kubectl -n karlcam get pods | grep public-frontend
          EOF

      - name: Cleanup
        if: always()
        run: |
          docker context rm ${{ env.DOCKER_CONTEXT_NAME }} --force || true

  build-and-deploy-pipeline-frontend:
    name: Build and Deploy Pipeline Frontend
    runs-on: self-hosted
    environment: prod
    needs: build-and-deploy-backend

    env:
      DOCKER_COMPOSE_FILE: docker-compose.prod.yml
      DOCKER_HOST: tcp://10.0.0.35:2375
      K8S_HOST: 10.0.0.40
      DOCKER_CONTEXT_NAME: karlcam-pipeline-frontend-ctx

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Pipeline Frontend
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build pipeline-frontend

      - name: List built images
        run: |
          echo "=== Pipeline frontend images after build ==="
          docker images | grep -E "(karlcam|frontend)" || echo "No matching images found"

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.K8S_HOST }} >> ~/.ssh/known_hosts

      - name: Set up Docker context
        run: |
          docker context create ${{ env.DOCKER_CONTEXT_NAME }} \
            --docker host=${{ env.DOCKER_HOST }} || true

      - name: Transfer and push pipeline frontend image to registry
        run: |
          local_image="karlcam-pipeline-frontend:latest"
          registry_image="10.0.0.35:5000/karlcam-pipeline-frontend:latest"
          
          echo "Transferring $local_image to remote Docker..."
          docker save "$local_image" | docker --context ${{ env.DOCKER_CONTEXT_NAME }} load
          
          echo "Tagging for registry: $registry_image"
          docker --context ${{ env.DOCKER_CONTEXT_NAME }} tag "$local_image" "$registry_image"
          
          echo "Pushing to registry: $registry_image"
          docker --context ${{ env.DOCKER_CONTEXT_NAME }} push "$registry_image"

      - name: Deploy pipeline frontend service to K8s
        run: |
          # Update manifests with registry image names
          sed -i 's|image: karlcam/\([^:]*\):latest|image: 10.0.0.35:5000/karlcam-\1:latest|g' k8s/05-pipeline-frontend.yaml
          
          # Copy pipeline frontend manifests to K8s control plane
          scp k8s/05-pipeline-frontend.yaml ubuntu@${{ env.K8S_HOST }}:/tmp/
          
          # Apply pipeline frontend manifests
          ssh ubuntu@${{ env.K8S_HOST }} << 'EOF'
            sudo kubectl apply -f /tmp/05-pipeline-frontend.yaml
            
            # Wait for pipeline frontend deployment
            sudo kubectl -n karlcam rollout status deployment/karlcam-pipeline-frontend --timeout=5m
            
            # Show complete status
            sudo kubectl -n karlcam get all
          EOF

      - name: Cleanup
        if: always()
        run: |
          docker context rm ${{ env.DOCKER_CONTEXT_NAME }} --force || true