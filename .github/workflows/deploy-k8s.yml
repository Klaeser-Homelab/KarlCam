name: Deploy to K8s

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-and-deploy-backend:
    name: Build and Deploy Backend Services
    runs-on: self-hosted
    environment: prod

    env:
      DOCKER_COMPOSE_FILE: docker-compose.prod.yml
      DOCKER_HOST: tcp://10.0.0.35:2375
      K8S_HOST: 10.0.0.40
      DOCKER_CONTEXT_NAME: fogcam-backend-ctx

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Clean Docker build cache
        run: |
          docker builder prune -a -f
          docker system prune -f

      - name: Build Pipeline service
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build pipeline

      - name: Build Backend service
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build backend

      - name: Tag images with correct names
        run: |
          # Tag images to match K8s manifest names
          docker tag fogcam-pipeline:latest karlcam-pipeline:latest || true
          docker tag karlcam-backend:latest karlcam-backend:latest || true

      - name: Set up Docker context
        run: |
          docker context create ${{ env.DOCKER_CONTEXT_NAME }} \
            --docker host=${{ env.DOCKER_HOST }} || true

      - name: Transfer backend images to remote Docker
        run: |
          for service in pipeline backend; do
            image_name="karlcam-${service}:latest"
            echo "Transferring $image_name to remote Docker..."
            docker save "$image_name" | docker --context ${{ env.DOCKER_CONTEXT_NAME }} load
          done

      - name: Deploy backend services to K8s
        run: |
          # Update manifests with correct image names
          for file in k8s/00-namespace.yaml k8s/01-storage.yaml k8s/02-pipeline.yaml k8s/03-backend.yaml; do
            sed -i 's|image: karlcam/\([^:]*\):latest|image: karlcam-\1:latest|g' $file
          done
          
          # Copy backend manifests to K8s control plane
          scp -o StrictHostKeyChecking=no k8s/00-namespace.yaml k8s/01-storage.yaml k8s/02-pipeline.yaml k8s/03-backend.yaml ubuntu@${{ env.K8S_HOST }}:/tmp/
          
          # Apply backend manifests
          ssh -o StrictHostKeyChecking=no ubuntu@${{ env.K8S_HOST }} << 'EOF'
            sudo kubectl apply -f /tmp/00-namespace.yaml
            sudo kubectl apply -f /tmp/01-storage.yaml
            sudo kubectl apply -f /tmp/02-pipeline.yaml
            sudo kubectl apply -f /tmp/03-backend.yaml
            
            # Wait for backend deployments
            sudo kubectl -n karlcam rollout status deployment/fogcam-pipeline --timeout=5m
            sudo kubectl -n karlcam rollout status deployment/karlcam-backend --timeout=5m
            
            # Show backend status
            sudo kubectl -n karlcam get pods
          EOF

      - name: Cleanup
        if: always()
        run: |
          docker context rm ${{ env.DOCKER_CONTEXT_NAME }} --force || true

  build-and-deploy-frontend:
    name: Build and Deploy Frontend Services
    runs-on: self-hosted
    environment: prod
    needs: build-and-deploy-backend

    env:
      DOCKER_COMPOSE_FILE: docker-compose.prod.yml
      DOCKER_HOST: tcp://10.0.0.35:2375
      K8S_HOST: 10.0.0.40
      DOCKER_CONTEXT_NAME: fogcam-frontend-ctx

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Public Frontend
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build public-frontend

      - name: Build Pipeline Frontend
        run: |
          docker compose -f ${{ env.DOCKER_COMPOSE_FILE }} build pipeline-frontend

      - name: Tag images with correct names
        run: |
          # Tag images to match K8s manifest names
          docker tag karlcam-public-frontend:latest karlcam-public-frontend:latest || true
          docker tag fogcam-pipeline-frontend:latest karlcam-pipeline-frontend:latest || true

      - name: Set up Docker context
        run: |
          docker context create ${{ env.DOCKER_CONTEXT_NAME }} \
            --docker host=${{ env.DOCKER_HOST }} || true

      - name: Transfer frontend images to remote Docker
        run: |
          for service in public-frontend pipeline-frontend; do
            image_name="karlcam-${service}:latest"
            echo "Transferring $image_name to remote Docker..."
            docker save "$image_name" | docker --context ${{ env.DOCKER_CONTEXT_NAME }} load
          done

      - name: Deploy frontend services to K8s
        run: |
          # Update manifests with correct image names
          for file in k8s/04-public-frontend.yaml k8s/05-pipeline-frontend.yaml; do
            sed -i 's|image: karlcam/\([^:]*\):latest|image: karlcam-\1:latest|g' $file
          done
          
          # Copy frontend manifests to K8s control plane
          scp -o StrictHostKeyChecking=no k8s/04-public-frontend.yaml k8s/05-pipeline-frontend.yaml ubuntu@${{ env.K8S_HOST }}:/tmp/
          
          # Apply frontend manifests
          ssh -o StrictHostKeyChecking=no ubuntu@${{ env.K8S_HOST }} << 'EOF'
            sudo kubectl apply -f /tmp/04-public-frontend.yaml
            sudo kubectl apply -f /tmp/05-pipeline-frontend.yaml
            
            # Wait for frontend deployments
            sudo kubectl -n karlcam rollout status deployment/karlcam-public-frontend --timeout=5m
            sudo kubectl -n karlcam rollout status deployment/fogcam-pipeline-frontend --timeout=5m
            
            # Show complete status
            sudo kubectl -n karlcam get all
          EOF

      - name: Cleanup
        if: always()
        run: |
          docker context rm ${{ env.DOCKER_CONTEXT_NAME }} --force || true
          docker image prune -f